<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Backspin Magnus Effect — p5.js Demo</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    body { margin: 0; background: #efefef; font-family: Arial, Helvetica, sans-serif; }
    #ui { position: absolute; left: 12px; top: 12px; background: rgba(255,255,255,0.92); padding: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.12); font-size: 13px; }
    label { display:block; margin-top:6px; }
    .small { font-size:12px; color:#444; }
  </style>
</head>
<body>
  <div id="ui">
    <div><strong>Backspin Magnus Effect</strong></div>
    <label>Pitch speed V (m/s): <span id="vVal">40</span></label>
    <input id="vSlider" type="range" min="10" max="50" value="40" step="1">
    <label>Spin (rpm): <span id="rpmVal">1800</span></label>
    <input id="rpmSlider" type="range" min="0" max="3500" value="1800" step="50">
    <label>Seam angle (deg): <span id="angleVal">0</span></label>
    <input id="angleSlider" type="range" min="-90" max="90" value="0" step="1">
    <div class="small" style="margin-top:6px;">
      <div>Computed ω (rad/s): <span id="omegaVal">188.5</span></div>
      <div>Spin parameter S: <span id="sVal">0.0175</span></div>
      <div>Lift coefficient C<sub>L</sub>: <span id="clVal">0.026</span></div>
      <div>Lift force F<sub>L</sub> (N): <span id="flVal">0.30</span></div>
    </div>
  </div>

  <script>
  // --- Physical constants and initial params
  const r = 0.037; // baseball radius (m)
  const mass = 0.145; // kg
  const rho = 1.225; // air density kg/m^3
  const A = Math.PI * r * r; // cross-sectional area
  const k_demo = 1.5; // empirical proportionality for C_L ≈ k * S (tuneable)
  const CL_MAX = 0.5;

  // Visualization state
  let canvasW = 1000, canvasH = 520;
  let particles = [];
  const N_PARTICLES = 220;
  let v = 40, rpm = 1800, seamAngleDeg = 0;

  // UI elements
  let vSlider, rpmSlider, angleSlider;
  let vVal, rpmVal, angleVal, omegaVal, sVal, clVal, flVal;

  function setup() {
    createCanvas(canvasW, canvasH);
    // UI bindings
    vSlider = select('#vSlider'); rpmSlider = select('#rpmSlider'); angleSlider = select('#angleSlider');
    vVal = select('#vVal'); rpmVal = select('#rpmVal'); angleVal = select('#angleVal');
    omegaVal = select('#omegaVal'); sVal = select('#sVal'); clVal = select('#clVal'); flVal = select('#flVal');

    vSlider.input(updateFromUI); rpmSlider.input(updateFromUI); angleSlider.input(updateFromUI);

    for (let i = 0; i < N_PARTICLES; i++) particles.push(randomParticle(true));
    frameRate(60);
  }

  function updateFromUI() {
    v = Number(vSlider.value());
    rpm = Number(rpmSlider.value());
    seamAngleDeg = Number(angleSlider.value());
    vVal.html(v); rpmVal.html(rpm); angleVal.html(seamAngleDeg);
  }

  function randomParticle(init=false) {
    // spawn particles from left side with slight vertical spread
    let y = random(40, height-40);
    let x = random(-width*0.25, -10);
    let speed = random(v*0.3, v*1.2);
    if (init) x = random(-width*0.5, width);
    return {x, y, speed, life: random(80, 300), age: 0};
  }

  function draw() {
    background(240);
    // compute physics
    const omega = (2 * Math.PI * rpm) / 60; // rad/s
    const S = (r * omega) / Math.max(0.0001, v);
    let CL = clamp(k_demo * S, 0, CL_MAX);
    const FL = 0.5 * rho * v * v * A * CL; // lift N
    // UI readouts
    omegaVal.html(omega.toFixed(1)); sVal.html(S.toFixed(4)); clVal.html(CL.toFixed(3)); flVal.html(FL.toFixed(2));

    // draw ground reference
    noStroke();
    fill(250);
    rect(0, height - 60, width, 60);

    // ball position moves left->right across centerline
    const t = (millis() / 1000) % 1000;
    const xBall = map((millis() / 1000) % 8, 0, 8, 80, width - 220); // loop every 8s
    const yBall = height/2 - 40; // baseline
    push();
    translate(xBall, yBall);

    // pressure overlay approximation (top low pressure blue, bottom higher red)
    push();
    noStroke();
    // top pressure intensity scales with relative top speed (V + rω)
    const vtop = v + r * omega;
    const vbot = Math.max(0.0001, v - r * omega);
    const topRel = vtop / (v + r*omega + v); // normalized
    const botRel = vbot / (v + r*omega + v);
    // a simple radial gradient via many concentric ellipses
    for (let i = 18; i > 0; i--) {
      let f = i / 18;
      let rPx = map(i, 0, 18, 0, 86);
      let tcol = lerpColor(color(30,120,220,180), color(255,100,100,110), 0.0);
      let alphaTop = map(vtop, v*0.9, v*2.5, 60, 10, true) * (1-f) ;
      let alphaBot = map(vbot, v*0.2, v*1.2, 10, 80, true) * (1-f) ;
      // top half blue overlay
      fill(30,120,220, alphaTop);
      ellipse(0, -rPx*0.18, rPx*1.2 * f + 10, rPx*0.55 + 10);
      // bottom half reddish overlay
      fill(255,90,70, alphaBot);
      ellipse(0, rPx*0.18, rPx*1.2 * f + 10, rPx*0.55 + 10);
    }
    pop();

    // draw streamlines as particles advected past ball with local speed modification
    updateParticles(xBall, yBall, omega);

    // draw baseball (circle + seam)
    noStroke();
    fill(255);
    ellipse(0, 0, 74, 74);

    // seam drawing (rotating)
    push();
    rotate(radians(seamAngleDeg));
    const seamRot = (omega * (millis()/1000) * 0.8) % (Math.PI*2);
    rotate(seamRot);
    stroke(160,20,20); strokeWeight(2.5);
    noFill();
    for (let s = -1; s <= 1; s+=2) {
      beginShape();
      for (let a = -PI/2; a <= PI/2; a += 0.08) {
        let sx = (34) * cos(a) * 0.9 * s;
        let sy = (20) * sin(a);
        vertex(sx, sy);
      }
      endShape();
    }
    pop();

    // draw spin indicator
    noFill(); stroke(60); strokeWeight(1.6);
    ellipse(-42, -38, 22, 22);
    noStroke(); fill(60);
    textSize(12); textAlign(LEFT, CENTER);
    text(`ω`, -54, -38);

    // draw velocity and force vectors
    drawVectors(CL, FL);

    pop(); // end ball transform

    // draw inset graph for C_L vs S (simple)
    drawInsetGraph(k_demo);

    // draw legend text
    noStroke();
    fill(30);
    textSize(13);
    textAlign(LEFT, TOP);
    text("Drag sliders to change V, spin (rpm), and seam angle. Backspin increases top relative speed → lower pressure → upward Magnus lift.", 12, height - 54);
  }

  function updateParticles(xBall, yBall, omega) {
    for (let p of particles) {
      // local effect: if particle near ball, alter speed and curve upward based on spin
      // convert to screen pixels: ball radius ~37 px
      let dx = p.x - xBall;
      let dy = p.y - yBall;
      let dist = Math.sqrt(dx*dx + dy*dy);
      // background advection to the right
      let baseVpx = map(v, 0, 50, 0.6, 3.6); // px per frame base
      // modify speed when near top or bottom of ball to hint faster top flow
      if (dist < 110) {
        // determine whether particle is above or below ball center
        let sign = (p.y < yBall) ? -1 : 1;
        // surface tangential speed in m/s at that side
        let tangential = r * omega * (sign * -1); // sign chosen so backspin gives top faster
        // relative local speed = V + sign * rω (screen effect)
        let rel = v + ( (p.y < yBall) ? r*omega : -r*omega );
        rel = constrain(rel, 0.2, v*2.5);
        let flowFactor = map(rel, 0, v*2.5, 0.2, 3.0);
        p.x += baseVpx * flowFactor;
        // slight vertical drift to show curvature
        p.y += map(sign * (rel - v), -v*1.2, v*1.2, -1.8, 1.8);
      } else {
        // far away: gentle right movement with small vertical jitter
        p.x += baseVpx * random(0.8,1.2);
        p.y += random(-0.4,0.4);
      }
      p.age++;
      if (p.x > width + 50 || p.age > p.life) {
        // respawn at left
        Object.assign(p, randomParticle(false));
        p.x = random(-width*0.2, -10);
      }
      // draw particle as small translucent line
      stroke(40, 120); strokeWeight(1);
      line(p.x, p.y, p.x - 4, p.y);
    }
  }

  function drawVectors(CL, FL) {
    // draw V vector at ball
    push();
    strokeWeight(3);
    // Velocity vector (right)
    stroke(30, 120, 200);
    line(-6, 44, 56, 44);
    fill(30,120,200); noStroke();
    triangle(56,44,48,40,48,48);
    // Lift vector (up) scaled for display
    let liftDisplay = map(FL, 0, 20, 0, 70); // scale mapping
    stroke(40,180,80); strokeWeight(3);
    line(10, 20, 10, 20 - liftDisplay);
    fill(40,180,80);
    noStroke();
    triangle(10, 20 - liftDisplay - 8, 6, 20 - liftDisplay + 6, 14, 20 - liftDisplay + 6);
    // Drag vector (left small)
    stroke(180,60,60); strokeWeight(3);
    line(-8, 44, -40, 44);
    fill(180,60,60); noStroke();
    triangle(-40,44,-32,48,-32,40);
    // labels
    noStroke(); fill(30);
    textSize(12); textAlign(LEFT, CENTER);
    text('V', 60, 44); text('F_L', 16, 20 - liftDisplay - 14);
    pop();
  }

  function drawInsetGraph(k_demo) {
    const w = 220, h = 110;
    const x = width - w - 12, y = 12;
    push();
    fill(255, 245); stroke(0,15); rect(x, y, w, h, 8);
    // axes
    push();
    translate(x+36, y+h-18);
    stroke(80); strokeWeight(1);
    line(0,0, 0, -72); line(0,0, 150, 0);
    noStroke(); fill(40); textSize(12); textAlign(LEFT, BOTTOM);
    text('C_L vs S', -34, -78);
    // plot theoretical C_L = k*S (clamped)
    let Smax = 0.12;
    stroke(30,120,200); noFill();
    beginShape();
    for (let i=0;i<=150;i++) {
      let sx = map(i,0,150,0,Smax);
      let CL = clamp(k_demo * sx, 0, CL_MAX);
      let px = map(sx, 0, Smax, 0, 150);
      let py = map(CL, 0, CL_MAX, 0, -72);
      vertex(px, py);
    }
    endShape();
    // current point
    const omega = (2 * Math.PI * rpm) / 60;
    const Scur = (r * omega) / Math.max(0.0001, v);
    const Ccur = clamp(k_demo * Scur, 0, CL_MAX);
    fill(200,30,30); noStroke();
    let cx = map(Scur, 0, Smax, 0, 150);
    let cy = map(Ccur, 0, CL_MAX, 0, -72);
    ellipse(cx, cy, 6,6);
    // axis labels
    noStroke(); fill(70); textSize(10); textAlign(CENTER);
    text('S', 75, 12); textAlign(RIGHT); text('C_L', -8, -36);
    pop();
    pop();
  }

  // utility
  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
  </script>
</body>
</html>
